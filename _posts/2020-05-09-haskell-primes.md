---
title: "Haskell - 소수 구하기"
categories:
  - Haskell
tags:
  - Haskell
  - Functional Programming Language
  - Coding
--- 

최근에 스칼라의 유명한 프레임워크인 Play Framework를 관리하던 Lightbend의 직원들의 퇴사 소식이 들려옴에 따라, 함수형 언어를 좋아하는 저로써는 장차 스칼라의 미래가 걱정되기 시작했습니다. 그래서 얼마전부터 하스켈 공부를 시작하게 되었는데요, 그 과정에서 최근에 배운 것 중, 인상 깊었던 것을 적어보고자 합니다.

# 하스켈로 소수 구하기

하스켈 책(Programming in Haskell)을 뒤적뒤적 하다보면, 리스트 챕터에서 소수를 구하는 코드를 작성하는 내용이 나옵니다. 다른 하스켈 책들도 리스트와 high-order function을 논할 때 항상 이 소수가 나옵니다.

이 포스팅에서는 하스켈을 이용하여 소수를 구하는 코드를 작성하고, 개선하는 작업을 해보겠습니다.

## 타 언어 살펴보기

우선, 짝수를 구하는 코드를 여러 언어로 살펴보겠습니다. 단순하게, n보다 같거나 작은 수의 짝수를 구하는 코드라 하면, 1 부터 n까지 반복자를 돌면서 2로 나눈 나머지가 0이면 짝수, 그렇지 않다면 홀수가 됩니다.

```c++
vector<int> evens(int until) {
    vector<int> ret(until + 1);
    for (int i = 1; i <= until; i++) {
        if (i % 2 == 0) ret.push_back(i);
        // or if (!(i & 1)) == ret.push_back(i);
    }
    return ret;
}
```

한편, 함수형 언어라 불리우는 스칼라도 비슷하게 줄여줄 수 있습니다.

```scala
def evens(n: Int): List[Int] = (1 to n).filter(_ % 2 == 0)
```

스칼라도 함수형 언어이므로 표현을 간결하게 둘 수 있습니다. 이제 찐 함수형 언어는 어떤지 살펴봅시다.

## 하스켈

하스켈은 Pure functional language라고 부르죠.. 상태가 전혀 없는 함수형 언어입니다.
특히, 수학의 집합을 표시하는 기호와 많이 닮은 점이 정말로 신기했습니다.

```haskell
evens :: Int -> [Int]
evens n = [x | x <- [1..n], x `mod` 2 == 0]
```

* `[1..n]`: 하스켈에서 Ranged 배열을 기술하는 방식으로, [1..5]이라 하면 [1,2,3,4,5]가 나오고, [1,3..10]이라 하면, [1,3,5,7,9]가 나옵니다.
한편, 위 evens는 [2,4..n]이라 표현하여도 무방합니다.

* `x <- [1..n]`: 이 표현은 1부터 n까지의 수가 있을 때, 하나씩 꺼내보는 Iterator입니다. 이제 저 x에 1부터 n까지의 수가 binding될 것입니다.

* ```x <- [1..n], x `mod` 2 == 0```: 이 표현은 [1..n] 리스트에서 각 x마다, 2로 나눈 나머지가 참인 값들을 전달합니다.

* `[x | ...]` : 이 표현은 가드 '\|' 의 오른쪽 조건을 충족하는 모든 x라고 이해할 수 있습니다. 한편, 여기에서도 변형을 줄 수 있습니다.

   ```[x * 2 | x <- [1..n]]```
   
   그리고 이 식은 `Functor`의 `map` 함수와 성질이 유사합니다.
   
   ```map (*2) [1..n]```

이상으로 한가지 구현에 대한 여러 표현법을 살펴봤습니다. 물론 하스켈의 단점도 있습니다. 순수 함수형이라는 이유로 선언 후 변경이 가능한 변수(Mutable variable)의 사용이 일절 없다보니 어렵지만, 일단 만들어지면 매우 Robust한 특징이 있습니다.

이제 본격적으로 하스켈로 소수를 구해봅시다.

# Prime Numbers with Haskell

소수를 구하는 방법은 여러가지가 있는데, 우선 가장 직관적인 것에서 시작해보겠습니다. 우선 아래의 명제로 시작해봅시다.

> 소수는 1과 자기 자신으로만 나누어 떨어지는 수이다.

이 명제를 기준으로, 이 포스팅에서는 n이 주어졌을 때, n이하의 모든 소수를 구하는 코드를 구현해보겠습니다.

## Initial 

우선, 문장을 분석해봅시다.

|     함수명      |                      설명                       |
| :----------: | :-------------------------------------------: |
|  `primes n`  |     n이 주어졌을 때, n이하의 isPrime을 충족하는 수들의 집합      |
| `isPrime n`  | divisors n이 1과 자기 자신으로만 구성되어 있을 때 이를 소수라 부른다. |
| `divisors n` |   n이하의 자연수 중, 이를 나눴을 때 나머지가 0인 수를 약수라 부른다.    |

하스켈은 
먼저, `primes n`을 코드로 표현해봅시다.
자연수는 1 ~ n 의 정수입니다. 이는 하스켈로 `[1..n]`로 표현합니다.

한편 하스켈에서, 리스트를 정의할 때 수학하고 비슷한 표기법으로 정의한다 했는데, 그 원리는 아래와 같습니다.

```hs
[(실제 원소로 남을 값) | (원소 들의 집합), (원소 값에 대한 규칙)]

primes n = [x | x <- [1..n], isPrime x]
```

그리고 소수는 앞서 말한대로, 1과 자기자신만 존재하는지 체크하면 됩니다.

```hs
isPrime n = [1, n] == divisors n
```
참고로 순서가 중요합니다. 만약 `divisors n`이 `[n, 1]`을 돌려준다면 소수임에도 불구하고 False가 리턴될 것입니다.
그렇지 않도록 출력을 제한하면 됩니다. 

한편, 어떤 수가 주어졌을 때, 이 수보다 작은 수들 중, 약수를 구하려면 어떤 수들의 집합에서, 나누어 떨어지는지 체크하는 조건문이 포함되어 있어야 하는데, 즉, 나머지를 체크하는 식이 포함되어야 합니다.
일반적인 프로그래밍 언어에서는 a % b를 많이 쓰지만, 하스켈에서는 ```a `mod` b``` 혹은, ```mod a b``` 이렇게 사용합니다.

```hs
divisors n = [x | x <- [1..n], n `mod` x == 0]
```

이 코드들을 조합하면, 네.. 3줄만에 소수를 구할 수 있습니다.

이제 위 코드를 정리하면 아래와 같습니다.

```haskell
divisors x = [x' | x' <- [1..x], x `mod` x' = 0]
isPrime x = [1, x] == divisors x
primes x = [x | x <- [1..x], prime x]
```

조금 반칙 같으니, 함수의 타입들도 붙여줘봅시다.
```hs
divisors :: Int -> [Int]
divisors x = [x' | x' <- [1..x], x `mod` x' = 0]

isPrime :: Int -> Bool
isPrime x = [1, x] == divisors x

primes :: Int -> [Int]
primes x = [x | x <- [1..x], prime x]
```

사실 하스켈을 처음 배울 때 정말로 이렇게 짧아질 수 있는지 싶어 놀라웠습니다.

이제 실제 세계에서 쓸 수 있으려면, 제약조건이 하나 필요합니다. 시간입니다. 하스켈이 우선 native한 환경에서 동작하기 때문에, 당연히 왠만한 스크립트 코드나 JVM계열의 언어보다는 빠르겠습니다만, ```primes x```의 시간 복잡도는 n까지의 수를 계산하라고 할 때, 우선 O(n^2)입니다.(divisors가 O(n), isPrime은 divisors로 인해 O(n), primes는 O(n * O(isPrimes)) = O(n^2)) 한마디로 최적화가 필요하죠..

## Improvement
두가지 방법을 살펴보겠습니다. 약수를 개선하는 방법과, 에라토스테네스의 채를 이용하는 방법입니다.

### 약수의 개선 
위의 코드에서 간단하게 개선해볼 수 있는 방법으로는, 반복자를 도는 횟수를 줄인다는 것에 착안합니다. 결국, 1 ~ x를 모두 비교하지 않고, 어떤 중간의 수에서 멈추는 방법입니다. 간단하게, 8이라는 수를 생각해봅시다.
정수가 아닌 실수들을 모두 고려하여 연산을 해봅시다.

```haskell
xs = [(x, 8 / x) | x <- [1..8]] 

1 -> 8.00
2 -> 4.00  -- 
3 -> 2.67  --
4 -> 2.00
5 -> 1.60
6 -> 1.33
7 -> 1.14
8 -> 1.00
```

어느 지점에서 나누는 수와 몫의 크기가 반전되는 곳을 살펴볼 수 있습니다. 정확히 이 지점이 어디인지를 찾아야 하는데, 9로 키워봅시다.

```hs
1 -> 9.00
2 -> 4.50
3 -> 3.00 --
4 -> 2.25
5 -> 1.80
6 -> 1.50
7 -> 1.29
8 -> 1.12
9 -> 1.00
```

숫자를 점점 키워가다보면, 제곱근 수와 일치하는 지점에서 수의 크기가 반전됨을 알 수 있습니다. 따라서, sqrt x만큼만 돌아도 나머지를 구할 수 있다는 결론이 됩니다. (재미있는 점은, 그래프 상에서 저렇게 수의 크기가 반전되는 지점을 찾는 방법이 뉴튼의 근사법입니다.)

```haskell

divisors x = [x' | x' <- [1..x], x `mod` x' = 0]

-- 제곱근 까지만 약수를 찾는 코드
divisorsHalf x = [x' | x' <- [1..n], x `mod` x' == 0]
    where n = round $ sqrt $ fromIntegral x / 1
-- divisorsHalf 9 = [1, 3]

-- 주어진 집합을 토대로 나머지 약수를 찾는 코드
divisorsRest x xs = [x `div` x' | x' <- xs]

-- divisorsRest 9 $ divisorsHalf 9 = [9, 3]
```

문제는 두 결과물을 합치면 `[1, 3, 9, 3]`이 나오는데, 우리가 원하지 않는 결과입니다. 즉, 중복을 지워야 하죠. 이를 지우는 방법으로, Set을 이용하는 방법이 있겠지만, 여기에서는 리스트를 정렬하여 merge하는 것으로 만들어봅시다.

```hs
merge xs ys = merge' acc xs' ys'
    where xs' = sort xs
          ys' = sort ys
          merge' acc []     []                 = merge'
          merge' acc []     (y:ys)             = merge' (acc ++ [y]) [] ys
          merge' acc (x:xs) (y:ys) | x == y    = merge' (acc ++ [y]) [] ys
                                   | otherwise = merge' (acc ++ [y]) [] ys
```

이제 이것을 가지고 divisors 함수를 다시 구성해봅시다.

```hs
divisors x = merge l r
    where l = divisorsHalf x
          r = divisorsRest x l
```

그리고 아까 구해둔 prime x와 primes x를 이용하면 처음 버전의 primes x보다는 빠른 성능으로 구할 수 있습니다.

한편, 모두 구한 후, merge 함수를 사용하는 대신, HashSet을 이용할 수도 있습니다.

```hs
import qualified Data.HashSet as Set

-- 제곱근 까지만 약수를 찾는 코드
divisors'' x = Set.fromList $ concat [[x', x / x'] | x' <- [1..n], x `mod` x' == 0]
    where n = round $ sqrt $ fromIntegral x / 1
```

### 에라토스테네스의 채

한편, 위의 방법들과 다르게 Memoization 기법을 이용하여 구할 수도 있습니다. 동적 프로그래밍... 만일, 이미 구해둔 소수로 나누어지는 값들은 그냥 살피지 않고 지나칠 수 있다면? 이 방법이 사실 에라토스테네스의 체입니다. 아시다시피, 미리 숫자들을 나열해놓고, 1 지우고, 2가 아닌 2의 배수를 지우고, 3이 아닌 3의 배수를 지워나가면서 남는 수들만으로 소수를 구하는 방법입니다. 이는 사실 상태변수를 가질 수 있는 일반적인 방법으로도 충분히 구해낼 수 있습니다.

아래는 C++로 간단하게 짜본 코드입니다.

```c++

vector<bool> xs(n, true);

for (int i = 2; i < n; i++) {
    for (int j = i * 2; j < n; j += i) {
        xs[j] = false;
    }
}
```

이처럼 Mutable한 자료구조가 있다면 손쉽게 구할 수 있습니다만, 아시다시피.. 함수형 언어는 전혀 그렇지가 않습니다.

나름대로 이 방법 저 방법을 생각해본 결과, 반복적으로 filter를 적용하는 것이 좋을 것 같았습니다.
우선 전체 수가 나열된 집합을 구하는 함수와, 자기 자신을 제외한 배수들을 걸러내는 함수를 만들어봅시다.
```hs
totalNumbers n = [2..n]
-- totalNumbers 10 = [2,3,4,5,6,7,8,9,10]

sieve :: Int -> [Int] -> [Int]
sieve xs n = filter (\x -> x == n || x `mod` n == 0) xs
-- sieve 2 (totalNumbers 10) = [3,5,7,9]

```

다음 반복자를 정의해봅시다. 2부터 시작하여 n 까지, 배수의 배열들을 이용해서 계속 제외해나가는 방식입니다.

```hs
primes' n = foldl (sieve) (totalNumbers n) [2..n]
```

동작시켜봤는데... 정말로 느립니다. 그냥 primes가 훨씬 빠르네요... 왜그런지 문제를 고민해봤습니다.